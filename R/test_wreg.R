#' Testing the relationship species attributes and sample attributes by fourth corner method
#' 
#' Function calculating the weightet linear regressions between CWM of species attributes (traits) and sample attributes (environmental variables) and between SNC of sample attributes and species attributes (sensu ter Braak et al. 2018), and testing them by parametric tests and their combination into max test.
#' 
#' @name test_wreg
#' @param env Vector, matrix or data frame with sample attributes (environemntal variables).
#' @param com Matrix of data frame with species composition data.
#' @param traits Vector, matrix or data frame with species attributes (traits)
#' @param test NEEDS FIX Vector of character values. Which test should be conducted? Partial match to \code{'rowbased'} row-based permutation test (called Model 2 in the Legendre et al. 1997 and Dray & Legendre 2008), \code{'colbased'} for column-based permutation test (Model 4), and \code{'max'} for max test (selecting the higher from \code{rowbased} and \code{colbased} result, Model 6). \code{'all'} includes all three tests. See \code{Details}.
#' @param adjustP Logical, default FALSE. Should be the P-values adjusted? If \code{adjustP = TRUE}, the last column in the results is adjusted by method selected in \code{p.adjust.method}.
#' @param p.adjust.method A string indicating the method of P-value adjustement, see \code{\link{p.adjust.methods}} for possible choices.
#' @param parallel NULL (default) or integer number. Number of cores for parallel calculation. Maximum number of cores should correspond to number of available cores on the processor.
#' @param x,object NEEDS FIX object of the class \code{"cwm"}, generated by function \code{cwm}.
#' @param digits number of digits reported by \code{print} method on object of \code{"cwm"} class (default is 3).
#' @param missing.summary Logical; should be the summary of values missing in \code{env}, \code{cwm} and \code{traits} be printed along to the result of \code{test_cwm} analysis? Default is \code{TRUE}.
#' @param eps.Pvalue Values of P below this threshold will be printed as \code{< [eps]} in the output.
#' @param signif.stars Logical; if TRUE, P-values are additionally encoded visually as 'significance stars' in order to help scanning of long coefficient tables. It defaults to the show.signif.stars slot of \code{\link{options}}.
#' @param alpha,line,cex.lab,par.mar,box.col,box.lwd Graphical parameters for \code{plot} function.
#' @param var_re,var_st Parameters for scaling function \code{rescale_axis}
#' @param ... Other arguments for \code{print}, \code{summary} or \code{coef} functions (not implemented yet).

#' @export
#' @examples 
#' data (vltava)
#' vltava.env <- vltava$env[,c('pH', 'COVERE32')]
#' vltava.com <- vltava$herbs$spe
#' vltava.traits <- vltava$herbs$traits
#' wreg <- test_wreg (env = vltava.env, com = vltava.com, traits = vltava.traits)
#' @details
#' In the current implementation, species with missing species attributes are removed from sample x species matrix prior to permutation of species attributes among species. 
#' @return  Function \code{test_wreg} returns the list of the class \code{"testWREG"} (with \code{print} and \code{summary} methods), which contains the following items: NEEDS TO FIX
#' \itemize{
#'  \item \code{call} Function call.
#'  \item \code{out} Data frame with results of calculation; the first column contains the original fourth corner metric (\code{r_fc}); following columns contain some of the following results of parametric tests: \code{P.row}, \code{P.col} and \code{P.max}. If \code{adjustP = TRUE}, the last column contains P values adjusted by \code{p.adjust} function.
#'  \item \code{miss} List with missing values of \code{env}, \code{traits} or \code{cwm} (the last provided for compatibility with \code{test_cwm} function and refers to samples which, after removing missing \code{traits} values, do not contain any species.)
#'  \item \code{param} Setting of input parameters (\code{perm} and \code{test}).
#'  }
#' @seealso \code{\link{cwm}} \code{\link{test_cwm}}
#' @importFrom graphics abline
#' @importFrom stats coef pf
#' @export
test_wreg <- function (env, com = NULL, traits = NULL, test = "all", parallel = NULL, p.adjust.method = p.adjust.methods, adjustP = FALSE)
{
  CALL <- match.call ()
  TEST <- c('none', 'rowbased', 'colbased', 'max', 'all')
  test <- match.arg (test, TEST, several.ok = T)
  if ('none' %in% test) test <- 'none'
  if ('all' %in% test) test <- c('rowbased', 'colbased', 'max')
  env <- as.data.frame (as.matrix (env))
  if (is.null (com) & is.null (traits))
    stop ('You need to provide species composition data and traits, either using com and traits arguments, or cwm!')
  traits <- as.data.frame (traits) # makes sure that even if the entry object is vector it can still calculate 
  if (ncol (as.matrix (com)) != nrow (as.matrix (traits))) stop ("The number of species in 'com' does not fit the number of species in 'traits'!")
  if (nrow (as.matrix (com)) != nrow (as.matrix (env))) stop ("The number of samples in 'com' does not fit the number of samples in 'env'!")
  vars.names <- expand.grid (traits = colnames (traits), env = colnames (env), stringsAsFactors = FALSE)
  if (is.null (parallel)) {
      res <- apply (vars.names, 1, FUN = function (var12) test_wreg_int (e = env[, var12['env'], drop = TRUE], L = as.matrix (com), t = traits[, var12['traits'], drop = TRUE]))
    }
    else
    {
      cl <- parallel::makeCluster (parallel)
      parallel::clusterExport (cl, varlist = c('vars.names', 'com', 'traits', 'env', 'test_wreg_int'), envir = environment ())
      parallel::clusterEvalQ (cl, eval (call ('library', 'weimea')))
      res <- parallel::parApply (cl, vars.names, 1, FUN = function (var12) test_wreg_int (e = as.matrix (env[, var12['env'], drop = F]), L = as.matrix (com), t = as.matrix (traits[, var12['traits'], drop = F])))
    }
    names (res) <- apply (vars.names, 1, FUN = function (x) paste (x[1], x[2], sep = ' / '))

  res.miss <- lapply (res, FUN = function (x) x[(length (x)-2):length (x)])
  res.coef <- lapply (res, FUN = function (x) x[1:(length (x)-3)])
  res.coef.df <- do.call (rbind.data.frame, res.coef)  # originally res.out
  test.choice <- c('rowbased', 'colbased', 'max')
  P.test <- c ('P_row', 'P_col', 'P_max')[test.choice %in% test]
  res.out <- cbind (res.coef.df [,!substr (colnames (res.coef.df), 1, 2) %in% 'P_'], res.coef.df[, P.test, drop = F])  # deletes all P values and adds only those specificed in "test" argument
  if (adjustP && test != 'none') {
    res.out <- cbind (res.out, p.adjust (res.out[, ncol (res.out)], method = p.adjust.method))
    colnames (res.out)[ncol (res.out)] <- paste (colnames (res.out)[ncol (res.out)-1], 'adj', sep = '_')
  }
  result <- list (call = CALL, out = res.out, miss = res.miss, param = list (test = test, p.adjust.method = p.adjust.methods, adjustP = adjustP), var.names = list (env = colnames (env), traits = colnames (traits)), orig.data = list (env = env, com = com, traits = traits))
  class (result) <- 'testWREG'
  return (result)
}

test_wreg_int <- function (e, L, t)
{
  eLt <- rm_missing_eLt (e = as.matrix (e), L = as.matrix (L), t = as.matrix (t))
  e_w <- weights::stdz (eLt$e, weight = rowSums (eLt$L))
  t_w <- weights::stdz (eLt$t, weight = colSums (eLt$L))
  CWM_w <- as.matrix (cwm (traits = t_w, com = eLt$L))
  SNC_w <- as.matrix (snc (env = e_w, com = eLt$L))
  lm_CWM_e <- lm (CWM_w ~ e_w, weights = rowSums (eLt$L))
  lm_SNC_t <- lm (SNC_w ~ t_w, weights = colSums (eLt$L))
  P_CWM <- pf (summary (lm_CWM_e)$fstatistic[1L], summary (lm_CWM_e)$fstatistic[2L], summary (lm_CWM_e)$fstatistic[3L], lower.tail = FALSE)
  P_SNC <- pf (summary (lm_SNC_t)$fstatistic[1L], summary (lm_SNC_t)$fstatistic[2L], summary (lm_SNC_t)$fstatistic[3L], lower.tail = FALSE)
  P_max <- max (P_CWM, P_SNC)
  return (list (r_fc = coef (lm_CWM_e)[2],
                n_sit = eLt$n_sit,
                n_spe = eLt$n_spe,
                P_row = P_CWM,
                P_col = P_SNC,
                P_max = P_max,
                e_missing = eLt$e_missing,
                t_missing = eLt$t_missing,
                c_missing = eLt$c_missing))
  }

#' @rdname test_wreg
#' @export
print.testWREG <- function (x, digits = max(3, getOption("digits") - 3), missing.summary = FALSE, eps.Pvalue = 0.001, signif.stars = getOption("show.signif.stars"),...)
{
  cs.ind <- c(1, 2)
  tst.ind <- 0
  df.ind <- c(3)
  cat("\nCall:\n", paste(deparse(x$call), sep = "\n", collapse = "\n"),
      "\n\n", sep = "")
  printCoefmat2 (x$out, digits = digits, cs.ind = cs.ind, tst.ind = tst.ind, df.ind = df.ind, eps.Pvalue = 0.001, signif.stars = signif.stars,...)
  if (missing.summary) printMissum (x$miss)
}

# This function is already in test_cwm, can be deleted here:
# printMissum <- function (x){
#   miss <- lapply (x, FUN = function (a) lapply (a, length))
#   miss <- as.matrix (do.call (rbind.data.frame, miss))
#   colnames (miss) <- c('env', 'traits', 'samples')
#   if (sum (miss) == 0) cat("\nThere are no missing env, traits or sample values.\n") else
#   {
#     cat("\nCount of missing values:\n")
#     print.default (miss)
#   }
#   invisible (miss)
#  }

#' @rdname test_wreg
#' @export
coef.testWREG <- function (object, ...)
  return (object$out)

#' @rdname test_wreg
rescale_axis <- function (x, var_re, var_st)
{
  at <- min (var_st) + ((x - min (var_re)) * ((max (var_st) - min (var_st))/(max (var_re) - min (var_re))))
  list (x = x, at = at)
}

#' @rdname test_wreg
#' @export
plot.testWREG <- function (x, alpha = 0.05, line = NA, cex.lab = 1.5, par.mar = c(0.5, 0.5, 0.5, 0.5), box.col = c('blue', 'red'), box.lwd = 2, ...){
  # function modelled according to plot.testCWM - keep the same arguments
  opar <- par (c('mfcol', 'mar', 'mgp', 'oma', 'xpd'))  # include all graphical par set globally
  
  trait.names <- x$var.names$traits
  env.names <- x$var.names$env
  TRA <- x$orig.data$traits
  ENV <- x$orig.data$env
  COM <- x$orig.data$com
  
  no_traits <- length (trait.names)
  no_env <- length (env.names)
  
  par (oma = c(3, 3, 1, 1))  # outer margin
  par (mgp = c(2, 0.3, 0))  # where title, axis labels and axis line should be plotted
  layout_matrix <- matrix (seq (1, length (trait.names)*length (env.names)), nrow = no_traits, byrow = FALSE)
  layout (layout_matrix)
  par (mar = par.mar, xpd = NA)
  
  test <- x$out[,max (which (substr (colnames (x$out), 1, 2) %in% 'P_'))]
  
  traits.env <- expand.grid (traits = trait.names, env = env.names)
  
  left_label <- vector ('logical', length = no_traits*no_env)
  left_label[1:nrow(layout_matrix)] <- TRUE
    
  bottom_label <- vector ('logical', length = no_traits*no_env)
  bottom_label [seq (nrow(layout_matrix), no_traits*no_env, by = nrow(layout_matrix))] <- TRUE
  
  traits.env <- cbind (traits.env, left_label = left_label, bottom_label = bottom_label)
  if (!is.null (test))
     traits.env <- cbind (traits.env, test = test, r = x$out$r_fc) 
  
  for (i in seq (1, nrow (traits.env)))
  {
    te <- traits.env[i,]
    TRA0 <- TRA[[te$traits]] 
    ENV0 <- ENV[,te$env]  
    COM0 <- COM[!is.na (ENV0), !is.na (TRA0)]  # remove species which have missing spe or sam attributes
    TRA0 <- TRA0[!is.na (TRA0)]
    ENV0 <- ENV0[!is.na (ENV0)]

    cwm_w <- as.matrix (cwm (com = COM0, traits = TRA0, wstand = TRUE))
    env_w <- weights::stdz (ENV0, weight = rowSums (COM0))
    lm_cwm_w <- lm (cwm_w ~ 0 + env_w, weights = rowSums (COM0))
    COM_rows_scaled <- vegan::decostand (rowSums (COM0), 'range')*1 + 0.5
    plot (cwm_w ~ env_w, asp = 1, pch = 16, ann = F, axes = F, cex = COM_rows_scaled)
    xaxis_re <- rescale_axis (pretty (ENV0), ENV0, env_w)
    axis (1, las = 1, at = if (te$bottom_label) xaxis_re$at else NULL, tck = 0.05, labels = if (te$bottom_label) xaxis_re$x else FALSE)
    yaxis_re <- rescale_axis (pretty (TRA0), TRA0, cwm_w)
    axis (2, las = 1, at = if (te$left_label) yaxis_re$at else NULL, tck = 0.05, labels = if (te$left_label) yaxis_re$x else FALSE)
    box (col = 'grey')
    title (xlab = ifelse (te$bottom_label, as.character (te$env), ''), ylab = ifelse (te$left_label, as.character (te$traits), ''), line = line, cex.lab = cex.lab)
    if (!is.null (test)) {
      bc <- ifelse (as.numeric (te$r) < 0, box.col[1], box.col[2])
      if (as.numeric (te$test) <= alpha){
        par (xpd = FALSE)
        abline (lm_cwm_w)
        par (xpd = NA)
        box (col = bc, lwd = box.lwd)
      } 
    }
  }
  par (opar)
  invisible ()
}
